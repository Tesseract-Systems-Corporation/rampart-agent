package watcher

import (
	"context"
	"testing"
	"time"

	"github.com/Tesseract-Systems-Corporation/rampart-agent/pkg/event"
)

func TestVulnerabilityWatcherInterface(t *testing.T) {
	var _ Watcher = (*VulnerabilityWatcher)(nil)
}

func TestVulnerabilityWatcherName(t *testing.T) {
	w := NewVulnerabilityWatcher(VulnerabilityConfig{
		FortressID: "fort_test",
		ServerID:   "srv_test",
	})
	if w.Name() != "vulnerability" {
		t.Errorf("Name() = %v, want vulnerability", w.Name())
	}
}

func TestVulnerabilityWatcherConfig(t *testing.T) {
	tests := []struct {
		name         string
		config       VulnerabilityConfig
		wantInterval time.Duration
		wantScanner  ScannerType
		wantTargets  int
	}{
		{
			name: "default values",
			config: VulnerabilityConfig{
				FortressID: "fort_test",
				ServerID:   "srv_test",
			},
			wantInterval: DefaultVulnerabilityInterval,
			wantScanner:  ScannerAuto,
			wantTargets:  1, // Default root filesystem
		},
		{
			name: "custom interval",
			config: VulnerabilityConfig{
				ScanInterval: 12 * time.Hour,
				FortressID:   "fort_test",
				ServerID:     "srv_test",
			},
			wantInterval: 12 * time.Hour,
			wantScanner:  ScannerAuto,
			wantTargets:  1,
		},
		{
			name: "trivy scanner",
			config: VulnerabilityConfig{
				Scanner:    ScannerTrivy,
				FortressID: "fort_test",
				ServerID:   "srv_test",
			},
			wantInterval: DefaultVulnerabilityInterval,
			wantScanner:  ScannerTrivy,
			wantTargets:  1,
		},
		{
			name: "grype scanner",
			config: VulnerabilityConfig{
				Scanner:    ScannerGrype,
				FortressID: "fort_test",
				ServerID:   "srv_test",
			},
			wantInterval: DefaultVulnerabilityInterval,
			wantScanner:  ScannerGrype,
			wantTargets:  1,
		},
		{
			name: "custom targets",
			config: VulnerabilityConfig{
				ScanTargets: []ScanTarget{
					{Type: ScanTargetFilesystem, Path: "/etc"},
					{Type: ScanTargetImage, Path: "nginx:latest"},
				},
				FortressID: "fort_test",
				ServerID:   "srv_test",
			},
			wantInterval: DefaultVulnerabilityInterval,
			wantScanner:  ScannerAuto,
			wantTargets:  2,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			w := NewVulnerabilityWatcher(tt.config)
			if w.scanInterval != tt.wantInterval {
				t.Errorf("scanInterval = %v, want %v", w.scanInterval, tt.wantInterval)
			}
			if w.scanner != tt.wantScanner {
				t.Errorf("scanner = %v, want %v", w.scanner, tt.wantScanner)
			}
			if len(w.scanTargets) != tt.wantTargets {
				t.Errorf("len(scanTargets) = %v, want %v", len(w.scanTargets), tt.wantTargets)
			}
		})
	}
}

func TestParseTrivyOutput(t *testing.T) {
	tests := []struct {
		name          string
		input         string
		wantFindings  int
		wantCritical  int
		wantHigh      int
		wantMedium    int
		wantLow       int
		wantErr       bool
	}{
		{
			name:          "empty output",
			input:         "",
			wantFindings:  0,
			wantCritical:  0,
			wantHigh:      0,
			wantMedium:    0,
			wantLow:       0,
			wantErr:       false,
		},
		{
			name:          "empty results",
			input:         `{"Results": []}`,
			wantFindings:  0,
			wantCritical:  0,
			wantHigh:      0,
			wantMedium:    0,
			wantLow:       0,
			wantErr:       false,
		},
		{
			name: "single critical vulnerability",
			input: `{
				"Results": [{
					"Target": "package-lock.json",
					"Vulnerabilities": [{
						"VulnerabilityID": "CVE-2021-44228",
						"PkgName": "log4j",
						"InstalledVersion": "2.14.0",
						"FixedVersion": "2.17.0",
						"Severity": "CRITICAL",
						"Description": "Log4Shell RCE vulnerability"
					}]
				}]
			}`,
			wantFindings:  1,
			wantCritical:  1,
			wantHigh:      0,
			wantMedium:    0,
			wantLow:       0,
			wantErr:       false,
		},
		{
			name: "multiple vulnerabilities mixed severity",
			input: `{
				"Results": [{
					"Target": "Gemfile.lock",
					"Vulnerabilities": [
						{
							"VulnerabilityID": "CVE-2022-1234",
							"PkgName": "rails",
							"InstalledVersion": "5.0.0",
							"FixedVersion": "5.0.1",
							"Severity": "HIGH",
							"Description": "XSS vulnerability"
						},
						{
							"VulnerabilityID": "CVE-2022-5678",
							"PkgName": "nokogiri",
							"InstalledVersion": "1.10.0",
							"FixedVersion": "1.10.5",
							"Severity": "MEDIUM",
							"Description": "XML parsing vulnerability"
						},
						{
							"VulnerabilityID": "CVE-2022-9999",
							"PkgName": "rack",
							"InstalledVersion": "2.0.0",
							"FixedVersion": "",
							"Severity": "LOW",
							"Description": "Minor info disclosure"
						}
					]
				}]
			}`,
			wantFindings:  3,
			wantCritical:  0,
			wantHigh:      1,
			wantMedium:    1,
			wantLow:       1,
			wantErr:       false,
		},
		{
			name: "multiple results",
			input: `{
				"Results": [
					{
						"Target": "app/package.json",
						"Vulnerabilities": [{
							"VulnerabilityID": "CVE-2021-1111",
							"PkgName": "lodash",
							"InstalledVersion": "4.17.0",
							"FixedVersion": "4.17.21",
							"Severity": "CRITICAL",
							"Description": "Prototype pollution"
						}]
					},
					{
						"Target": "api/requirements.txt",
						"Vulnerabilities": [{
							"VulnerabilityID": "CVE-2021-2222",
							"PkgName": "flask",
							"InstalledVersion": "1.0.0",
							"FixedVersion": "1.0.5",
							"Severity": "HIGH",
							"Description": "Security bypass"
						}]
					}
				]
			}`,
			wantFindings:  2,
			wantCritical:  1,
			wantHigh:      1,
			wantMedium:    0,
			wantLow:       0,
			wantErr:       false,
		},
		{
			name: "with title instead of description",
			input: `{
				"Results": [{
					"Target": "package.json",
					"Vulnerabilities": [{
						"VulnerabilityID": "CVE-2023-1234",
						"PkgName": "express",
						"InstalledVersion": "4.17.0",
						"FixedVersion": "4.18.0",
						"Severity": "MEDIUM",
						"Title": "Open redirect vulnerability",
						"Description": "This is a much longer description that explains the vulnerability in detail and how it can be exploited by an attacker."
					}]
				}]
			}`,
			wantFindings:  1,
			wantCritical:  0,
			wantHigh:      0,
			wantMedium:    1,
			wantLow:       0,
			wantErr:       false,
		},
		{
			name:         "invalid json",
			input:        `{invalid json}`,
			wantFindings: 0,
			wantErr:      true,
		},
		{
			name: "no vulnerabilities in result",
			input: `{
				"Results": [{
					"Target": "package.json",
					"Vulnerabilities": null
				}]
			}`,
			wantFindings:  0,
			wantCritical:  0,
			wantHigh:      0,
			wantMedium:    0,
			wantLow:       0,
			wantErr:       false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := ParseTrivyOutput([]byte(tt.input))

			if (err != nil) != tt.wantErr {
				t.Errorf("ParseTrivyOutput() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if tt.wantErr {
				return
			}

			if len(result.Findings) != tt.wantFindings {
				t.Errorf("Findings count = %d, want %d", len(result.Findings), tt.wantFindings)
			}
			if result.CriticalCount != tt.wantCritical {
				t.Errorf("CriticalCount = %d, want %d", result.CriticalCount, tt.wantCritical)
			}
			if result.HighCount != tt.wantHigh {
				t.Errorf("HighCount = %d, want %d", result.HighCount, tt.wantHigh)
			}
			if result.MediumCount != tt.wantMedium {
				t.Errorf("MediumCount = %d, want %d", result.MediumCount, tt.wantMedium)
			}
			if result.LowCount != tt.wantLow {
				t.Errorf("LowCount = %d, want %d", result.LowCount, tt.wantLow)
			}
		})
	}
}

func TestParseTrivyOutputVulnerabilityDetails(t *testing.T) {
	input := `{
		"Results": [{
			"Target": "package.json",
			"Vulnerabilities": [{
				"VulnerabilityID": "CVE-2021-44228",
				"PkgName": "log4j-core",
				"InstalledVersion": "2.14.0",
				"FixedVersion": "2.17.0",
				"Severity": "CRITICAL",
				"Description": "Remote code execution vulnerability"
			}]
		}]
	}`

	result, err := ParseTrivyOutput([]byte(input))
	if err != nil {
		t.Fatalf("ParseTrivyOutput() error = %v", err)
	}

	if len(result.Findings) != 1 {
		t.Fatalf("expected 1 finding, got %d", len(result.Findings))
	}

	v := result.Findings[0]
	if v.CVE != "CVE-2021-44228" {
		t.Errorf("CVE = %s, want CVE-2021-44228", v.CVE)
	}
	if v.Package != "log4j-core" {
		t.Errorf("Package = %s, want log4j-core", v.Package)
	}
	if v.InstalledVersion != "2.14.0" {
		t.Errorf("InstalledVersion = %s, want 2.14.0", v.InstalledVersion)
	}
	if v.FixedVersion != "2.17.0" {
		t.Errorf("FixedVersion = %s, want 2.17.0", v.FixedVersion)
	}
	if v.Severity != "critical" {
		t.Errorf("Severity = %s, want critical", v.Severity)
	}
	if v.Description != "Remote code execution vulnerability" {
		t.Errorf("Description = %s, want Remote code execution vulnerability", v.Description)
	}
}

func TestParseGrypeOutput(t *testing.T) {
	tests := []struct {
		name          string
		input         string
		wantFindings  int
		wantCritical  int
		wantHigh      int
		wantMedium    int
		wantLow       int
		wantErr       bool
	}{
		{
			name:          "empty output",
			input:         "",
			wantFindings:  0,
			wantCritical:  0,
			wantHigh:      0,
			wantMedium:    0,
			wantLow:       0,
			wantErr:       false,
		},
		{
			name:          "empty matches",
			input:         `{"matches": []}`,
			wantFindings:  0,
			wantCritical:  0,
			wantHigh:      0,
			wantMedium:    0,
			wantLow:       0,
			wantErr:       false,
		},
		{
			name: "single critical vulnerability",
			input: `{
				"matches": [{
					"vulnerability": {
						"id": "CVE-2021-44228",
						"severity": "Critical",
						"description": "Log4Shell RCE",
						"fix": {
							"versions": ["2.17.0"],
							"state": "fixed"
						}
					},
					"artifact": {
						"name": "log4j-core",
						"version": "2.14.0",
						"type": "java-archive"
					}
				}]
			}`,
			wantFindings:  1,
			wantCritical:  1,
			wantHigh:      0,
			wantMedium:    0,
			wantLow:       0,
			wantErr:       false,
		},
		{
			name: "multiple vulnerabilities mixed severity",
			input: `{
				"matches": [
					{
						"vulnerability": {
							"id": "CVE-2022-1111",
							"severity": "High",
							"description": "Security issue",
							"fix": {
								"versions": ["1.2.3"],
								"state": "fixed"
							}
						},
						"artifact": {
							"name": "vulnerable-pkg",
							"version": "1.0.0",
							"type": "npm"
						}
					},
					{
						"vulnerability": {
							"id": "CVE-2022-2222",
							"severity": "Medium",
							"description": "Another issue",
							"fix": {
								"versions": [],
								"state": "not-fixed"
							}
						},
						"artifact": {
							"name": "another-pkg",
							"version": "2.0.0",
							"type": "npm"
						}
					},
					{
						"vulnerability": {
							"id": "CVE-2022-3333",
							"severity": "Low",
							"description": "Minor issue",
							"fix": {
								"versions": ["3.0.1"],
								"state": "fixed"
							}
						},
						"artifact": {
							"name": "minor-pkg",
							"version": "3.0.0",
							"type": "npm"
						}
					}
				]
			}`,
			wantFindings:  3,
			wantCritical:  0,
			wantHigh:      1,
			wantMedium:    1,
			wantLow:       1,
			wantErr:       false,
		},
		{
			name: "negligible severity maps to low",
			input: `{
				"matches": [{
					"vulnerability": {
						"id": "CVE-2022-0000",
						"severity": "Negligible",
						"description": "Very minor issue",
						"fix": {
							"versions": [],
							"state": "wont-fix"
						}
					},
					"artifact": {
						"name": "some-pkg",
						"version": "1.0.0",
						"type": "apk"
					}
				}]
			}`,
			wantFindings:  1,
			wantCritical:  0,
			wantHigh:      0,
			wantMedium:    0,
			wantLow:       1,
			wantErr:       false,
		},
		{
			name:         "invalid json",
			input:        `{invalid json}`,
			wantFindings: 0,
			wantErr:      true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := ParseGrypeOutput([]byte(tt.input))

			if (err != nil) != tt.wantErr {
				t.Errorf("ParseGrypeOutput() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if tt.wantErr {
				return
			}

			if len(result.Findings) != tt.wantFindings {
				t.Errorf("Findings count = %d, want %d", len(result.Findings), tt.wantFindings)
			}
			if result.CriticalCount != tt.wantCritical {
				t.Errorf("CriticalCount = %d, want %d", result.CriticalCount, tt.wantCritical)
			}
			if result.HighCount != tt.wantHigh {
				t.Errorf("HighCount = %d, want %d", result.HighCount, tt.wantHigh)
			}
			if result.MediumCount != tt.wantMedium {
				t.Errorf("MediumCount = %d, want %d", result.MediumCount, tt.wantMedium)
			}
			if result.LowCount != tt.wantLow {
				t.Errorf("LowCount = %d, want %d", result.LowCount, tt.wantLow)
			}
		})
	}
}

func TestParseGrypeOutputVulnerabilityDetails(t *testing.T) {
	input := `{
		"matches": [{
			"vulnerability": {
				"id": "CVE-2021-44228",
				"severity": "Critical",
				"description": "Remote code execution via JNDI",
				"fix": {
					"versions": ["2.17.0", "2.12.3"],
					"state": "fixed"
				}
			},
			"artifact": {
				"name": "log4j-core",
				"version": "2.14.0",
				"type": "java-archive"
			}
		}]
	}`

	result, err := ParseGrypeOutput([]byte(input))
	if err != nil {
		t.Fatalf("ParseGrypeOutput() error = %v", err)
	}

	if len(result.Findings) != 1 {
		t.Fatalf("expected 1 finding, got %d", len(result.Findings))
	}

	v := result.Findings[0]
	if v.CVE != "CVE-2021-44228" {
		t.Errorf("CVE = %s, want CVE-2021-44228", v.CVE)
	}
	if v.Package != "log4j-core" {
		t.Errorf("Package = %s, want log4j-core", v.Package)
	}
	if v.InstalledVersion != "2.14.0" {
		t.Errorf("InstalledVersion = %s, want 2.14.0", v.InstalledVersion)
	}
	if v.FixedVersion != "2.17.0" {
		t.Errorf("FixedVersion = %s, want 2.17.0 (first fix version)", v.FixedVersion)
	}
	if v.Severity != "critical" {
		t.Errorf("Severity = %s, want critical", v.Severity)
	}
}

func TestNormalizeSeverity(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"CRITICAL", "critical"},
		{"Critical", "critical"},
		{"critical", "critical"},
		{"HIGH", "high"},
		{"High", "high"},
		{"high", "high"},
		{"MEDIUM", "medium"},
		{"Medium", "medium"},
		{"medium", "medium"},
		{"LOW", "low"},
		{"Low", "low"},
		{"low", "low"},
		{"Negligible", "low"},
		{"NEGLIGIBLE", "low"},
		{"Unknown", "low"},
		{"UNKNOWN", "low"},
		{"", "low"},
		{"SomeOtherValue", "low"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			result := normalizeSeverity(tt.input)
			if result != tt.expected {
				t.Errorf("normalizeSeverity(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}

func TestTruncateDescription(t *testing.T) {
	tests := []struct {
		name        string
		description string
		title       string
		maxLen      int
	}{
		{
			name:        "short description no title",
			description: "Short description",
			title:       "",
		},
		{
			name:        "short description with title",
			description: "This is a longer description",
			title:       "Short title",
		},
		{
			name:        "long description truncated",
			description: "This is a very long description that exceeds the maximum length and should be truncated to fit within the allowed character limit. It contains many words to ensure it goes over the limit and we can verify the truncation works correctly with the ellipsis.",
			title:       "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := truncateDescription(tt.description, tt.title)
			if len(result) > 200 {
				t.Errorf("truncateDescription() returned %d chars, want <= 200", len(result))
			}
		})
	}
}

func TestVulnerabilityWatcherContextCancellation(t *testing.T) {
	w := NewVulnerabilityWatcher(VulnerabilityConfig{
		ScanInterval: 1 * time.Hour, // Long interval
		FortressID:   "fort_test",
		ServerID:     "srv_test",
	})

	ctx, cancel := context.WithCancel(context.Background())

	ch, err := w.Watch(ctx)
	if err != nil {
		t.Fatalf("Watch() error = %v", err)
	}

	// Cancel immediately
	cancel()

	// Channel should close
	select {
	case _, ok := <-ch:
		if ok {
			for range ch {
			}
		}
	case <-time.After(2 * time.Second):
		t.Error("channel did not close after context cancellation")
	}
}

func TestCreateScanEvent(t *testing.T) {
	w := NewVulnerabilityWatcher(VulnerabilityConfig{
		FortressID: "fort_test",
		ServerID:   "srv_test",
	})

	result := &ScanResult{
		Findings: []event.VulnerabilityItem{
			{
				CVE:              "CVE-2021-44228",
				Package:          "log4j",
				InstalledVersion: "2.14.0",
				FixedVersion:     "2.17.0",
				Severity:         "critical",
			},
		},
		CriticalCount: 1,
		HighCount:     0,
		MediumCount:   0,
		LowCount:      0,
	}

	target := ScanTarget{Type: ScanTargetFilesystem, Path: "/"}
	e := w.createScanEvent(ScannerTrivy, target, result)

	if e.Type != event.VulnerabilityScan {
		t.Errorf("Type = %v, want %v", e.Type, event.VulnerabilityScan)
	}
	if e.FortressID != "fort_test" {
		t.Errorf("FortressID = %v, want fort_test", e.FortressID)
	}
	if e.ServerID != "srv_test" {
		t.Errorf("ServerID = %v, want srv_test", e.ServerID)
	}

	payload := e.Payload
	if payload["scan_type"] != "package" {
		t.Errorf("scan_type = %v, want package", payload["scan_type"])
	}
	if payload["scanner"] != "trivy" {
		t.Errorf("scanner = %v, want trivy", payload["scanner"])
	}
	if payload["target"] != "/" {
		t.Errorf("target = %v, want /", payload["target"])
	}
	if payload["total_findings"] != 1 {
		t.Errorf("total_findings = %v, want 1", payload["total_findings"])
	}
	if payload["critical_count"] != 1 {
		t.Errorf("critical_count = %v, want 1", payload["critical_count"])
	}
}

func TestCreateScanEventContainerTarget(t *testing.T) {
	w := NewVulnerabilityWatcher(VulnerabilityConfig{
		FortressID: "fort_test",
		ServerID:   "srv_test",
	})

	result := &ScanResult{
		Findings:      []event.VulnerabilityItem{},
		CriticalCount: 0,
		HighCount:     0,
		MediumCount:   0,
		LowCount:      0,
	}

	target := ScanTarget{Type: ScanTargetImage, Path: "nginx:latest"}
	e := w.createScanEvent(ScannerGrype, target, result)

	payload := e.Payload
	if payload["scan_type"] != "container" {
		t.Errorf("scan_type = %v, want container", payload["scan_type"])
	}
	if payload["scanner"] != "grype" {
		t.Errorf("scanner = %v, want grype", payload["scanner"])
	}
	if payload["target"] != "nginx:latest" {
		t.Errorf("target = %v, want nginx:latest", payload["target"])
	}
}

func TestSeverityCounting(t *testing.T) {
	input := `{
		"Results": [{
			"Target": "test",
			"Vulnerabilities": [
				{"VulnerabilityID": "CVE-1", "PkgName": "a", "InstalledVersion": "1", "Severity": "CRITICAL"},
				{"VulnerabilityID": "CVE-2", "PkgName": "b", "InstalledVersion": "1", "Severity": "CRITICAL"},
				{"VulnerabilityID": "CVE-3", "PkgName": "c", "InstalledVersion": "1", "Severity": "HIGH"},
				{"VulnerabilityID": "CVE-4", "PkgName": "d", "InstalledVersion": "1", "Severity": "HIGH"},
				{"VulnerabilityID": "CVE-5", "PkgName": "e", "InstalledVersion": "1", "Severity": "HIGH"},
				{"VulnerabilityID": "CVE-6", "PkgName": "f", "InstalledVersion": "1", "Severity": "MEDIUM"},
				{"VulnerabilityID": "CVE-7", "PkgName": "g", "InstalledVersion": "1", "Severity": "LOW"}
			]
		}]
	}`

	result, err := ParseTrivyOutput([]byte(input))
	if err != nil {
		t.Fatalf("ParseTrivyOutput() error = %v", err)
	}

	if result.CriticalCount != 2 {
		t.Errorf("CriticalCount = %d, want 2", result.CriticalCount)
	}
	if result.HighCount != 3 {
		t.Errorf("HighCount = %d, want 3", result.HighCount)
	}
	if result.MediumCount != 1 {
		t.Errorf("MediumCount = %d, want 1", result.MediumCount)
	}
	if result.LowCount != 1 {
		t.Errorf("LowCount = %d, want 1", result.LowCount)
	}

	total := result.CriticalCount + result.HighCount + result.MediumCount + result.LowCount
	if total != len(result.Findings) {
		t.Errorf("severity counts (%d) don't match findings count (%d)", total, len(result.Findings))
	}
}

func TestScannerTypes(t *testing.T) {
	// Test all scanner types are defined
	scannerTypes := []ScannerType{
		ScannerAuto,
		ScannerTrivy,
		ScannerGrype,
	}

	for _, st := range scannerTypes {
		if st == "" {
			t.Error("scanner type should not be empty")
		}
	}

	// Test string values
	if string(ScannerAuto) != "auto" {
		t.Errorf("ScannerAuto = %v, want auto", ScannerAuto)
	}
	if string(ScannerTrivy) != "trivy" {
		t.Errorf("ScannerTrivy = %v, want trivy", ScannerTrivy)
	}
	if string(ScannerGrype) != "grype" {
		t.Errorf("ScannerGrype = %v, want grype", ScannerGrype)
	}
}

func TestScanTargetTypes(t *testing.T) {
	// Test all target types are defined
	targetTypes := []ScanTargetType{
		ScanTargetFilesystem,
		ScanTargetImage,
	}

	for _, tt := range targetTypes {
		if tt == "" {
			t.Error("target type should not be empty")
		}
	}

	// Test string values
	if string(ScanTargetFilesystem) != "filesystem" {
		t.Errorf("ScanTargetFilesystem = %v, want filesystem", ScanTargetFilesystem)
	}
	if string(ScanTargetImage) != "image" {
		t.Errorf("ScanTargetImage = %v, want image", ScanTargetImage)
	}
}

func TestDefaultVulnerabilityInterval(t *testing.T) {
	if DefaultVulnerabilityInterval != 24*time.Hour {
		t.Errorf("DefaultVulnerabilityInterval = %v, want 24h", DefaultVulnerabilityInterval)
	}
}

func TestVulnerabilityWatcherTriggerScan(t *testing.T) {
	t.Skip("Requires scanner installation - skipping in unit tests")
	// TriggerScan requires context and output channel
	// and will attempt to run actual scans
}

func TestVulnerabilityWatcherScanTargetsAccess(t *testing.T) {
	w := NewVulnerabilityWatcher(VulnerabilityConfig{
		FortressID: "fort_test",
		ServerID:   "srv_test",
		ScanTargets: []ScanTarget{
			{Type: ScanTargetFilesystem, Path: "/"},
			{Type: ScanTargetImage, Path: "nginx:latest"},
		},
	})

	// Test that scan targets are stored correctly
	if len(w.scanTargets) != 2 {
		t.Errorf("target count = %d, want 2", len(w.scanTargets))
	}

	if w.scanTargets[0].Type != ScanTargetFilesystem {
		t.Errorf("first target type = %v, want filesystem", w.scanTargets[0].Type)
	}
	if w.scanTargets[0].Path != "/" {
		t.Errorf("first target path = %v, want /", w.scanTargets[0].Path)
	}

	if w.scanTargets[1].Type != ScanTargetImage {
		t.Errorf("second target type = %v, want image", w.scanTargets[1].Type)
	}
	if w.scanTargets[1].Path != "nginx:latest" {
		t.Errorf("second target path = %v, want nginx:latest", w.scanTargets[1].Path)
	}
}

func TestScanResultEmpty(t *testing.T) {
	result := &ScanResult{
		Findings:      []event.VulnerabilityItem{},
		CriticalCount: 0,
		HighCount:     0,
		MediumCount:   0,
		LowCount:      0,
	}

	if len(result.Findings) != 0 {
		t.Errorf("Findings count = %d, want 0", len(result.Findings))
	}
	if result.CriticalCount != 0 {
		t.Errorf("CriticalCount = %d, want 0", result.CriticalCount)
	}
}

func TestTruncateDescriptionEdgeCases(t *testing.T) {
	tests := []struct {
		name        string
		description string
		title       string
		maxLen      int
	}{
		{
			name:        "empty description with title",
			description: "",
			title:       "Short title",
		},
		{
			name:        "both empty",
			description: "",
			title:       "",
		},
		{
			name:        "title only",
			description: "",
			title:       "This is the title that will be used",
		},
		{
			name:        "exact max length",
			description: "A description that is exactly two hundred characters long which should fit perfectly without any truncation needed at all period the end",
			title:       "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := truncateDescription(tt.description, tt.title)
			if len(result) > 200 {
				t.Errorf("truncateDescription() returned %d chars, want <= 200", len(result))
			}
		})
	}
}

func TestParseGrypeOutputWithRelatedVulnerabilities(t *testing.T) {
	input := `{
		"matches": [{
			"vulnerability": {
				"id": "CVE-2021-44228",
				"severity": "Critical",
				"description": "RCE vulnerability",
				"relatedVulnerabilities": [
					{"id": "GHSA-jfh8-c2jp-5v3q"}
				],
				"fix": {
					"versions": ["2.17.0"],
					"state": "fixed"
				}
			},
			"artifact": {
				"name": "log4j-core",
				"version": "2.14.0",
				"type": "java-archive"
			}
		}]
	}`

	result, err := ParseGrypeOutput([]byte(input))
	if err != nil {
		t.Fatalf("ParseGrypeOutput() error = %v", err)
	}

	if len(result.Findings) != 1 {
		t.Errorf("Findings count = %d, want 1", len(result.Findings))
	}
}

func TestParseTrivyOutputWithPrimaryURL(t *testing.T) {
	input := `{
		"Results": [{
			"Target": "package.json",
			"Vulnerabilities": [{
				"VulnerabilityID": "CVE-2021-44228",
				"PkgName": "log4j",
				"InstalledVersion": "2.14.0",
				"FixedVersion": "2.17.0",
				"Severity": "CRITICAL",
				"Description": "RCE vulnerability",
				"PrimaryURL": "https://nvd.nist.gov/vuln/detail/CVE-2021-44228"
			}]
		}]
	}`

	result, err := ParseTrivyOutput([]byte(input))
	if err != nil {
		t.Fatalf("ParseTrivyOutput() error = %v", err)
	}

	if len(result.Findings) != 1 {
		t.Errorf("Findings count = %d, want 1", len(result.Findings))
	}
}
