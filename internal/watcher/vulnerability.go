package watcher

import (
	"context"
	"encoding/json"
	"log/slog"
	"os/exec"
	"strings"
	"time"

	"github.com/Tesseract-Systems-Corporation/rampart-agent/internal/platform"
	"github.com/Tesseract-Systems-Corporation/rampart-agent/pkg/event"
)

// DefaultVulnerabilityInterval is the default interval between vulnerability scans.
const DefaultVulnerabilityInterval = 24 * time.Hour

// ScannerType represents the vulnerability scanner to use.
type ScannerType string

const (
	ScannerTrivy ScannerType = "trivy"
	ScannerGrype ScannerType = "grype"
	ScannerAuto  ScannerType = "auto"
)

// ScanTargetType represents the type of scan target.
type ScanTargetType string

const (
	ScanTargetFilesystem ScanTargetType = "filesystem"
	ScanTargetImage      ScanTargetType = "image"
)

// ScanTarget represents a target for vulnerability scanning.
type ScanTarget struct {
	// Type is "filesystem" or "image"
	Type ScanTargetType `yaml:"type"`

	// Path is the filesystem path or container image reference
	Path string `yaml:"path"`
}

// VulnerabilityConfig holds configuration for the Vulnerability watcher.
type VulnerabilityConfig struct {
	// ScanInterval is how often to run vulnerability scans.
	// Defaults to DefaultVulnerabilityInterval (24 hours) if zero.
	ScanInterval time.Duration

	// Scanner is which scanner to use (trivy, grype, or auto).
	// Auto will try trivy first, then grype.
	Scanner ScannerType

	// ScanTargets is a list of targets to scan.
	// If empty, defaults to scanning the root filesystem.
	ScanTargets []ScanTarget

	// FortressID is the ID of the Fortress this agent belongs to.
	FortressID string

	// ServerID is the ID of this server.
	ServerID string

	// Logger is the logger to use. If nil, uses slog.Default().
	Logger *slog.Logger
}

// VulnerabilityWatcher runs periodic vulnerability scans for SOC 2 CC7.1 compliance.
type VulnerabilityWatcher struct {
	scanInterval time.Duration
	scanner      ScannerType
	scanTargets  []ScanTarget
	fortressID   string
	serverID     string
	logger       *slog.Logger

	// trivyPath caches the path to the trivy binary
	trivyPath string

	// osInfo caches the detected OS information
	osInfo platform.OSInfo

	// execCommand is used for testing to mock exec.Command
	execCommand func(name string, arg ...string) *exec.Cmd
}

// NewVulnerabilityWatcher creates a new VulnerabilityWatcher with the given configuration.
func NewVulnerabilityWatcher(cfg VulnerabilityConfig) *VulnerabilityWatcher {
	interval := cfg.ScanInterval
	if interval == 0 {
		interval = DefaultVulnerabilityInterval
	}

	scanner := cfg.Scanner
	if scanner == "" {
		scanner = ScannerAuto
	}

	targets := cfg.ScanTargets
	if len(targets) == 0 {
		targets = []ScanTarget{
			{Type: ScanTargetFilesystem, Path: "/"},
		}
	}

	logger := cfg.Logger
	if logger == nil {
		logger = slog.Default()
	}

	// Detect OS at startup for distro-specific security tracker links
	osInfo := platform.DetectOS()
	logger.Info("detected operating system",
		"id", osInfo.ID,
		"name", osInfo.Name,
		"version", osInfo.Version,
	)

	return &VulnerabilityWatcher{
		scanInterval: interval,
		scanner:      scanner,
		scanTargets:  targets,
		fortressID:   cfg.FortressID,
		serverID:     cfg.ServerID,
		logger:       logger,
		osInfo:       osInfo,
		execCommand:  exec.Command,
	}
}

// Watch starts watching and returns a channel of events.
func (w *VulnerabilityWatcher) Watch(ctx context.Context) (<-chan event.Event, error) {
	out := make(chan event.Event)

	go func() {
		defer close(out)

		w.logger.Info("starting vulnerability watcher",
			"interval", w.scanInterval,
			"scanner", w.scanner,
			"targets", len(w.scanTargets),
		)

		// Run initial scan
		w.runScans(ctx, out)

		ticker := time.NewTicker(w.scanInterval)
		defer ticker.Stop()

		for {
			select {
			case <-ctx.Done():
				w.logger.Info("vulnerability watcher stopped", "reason", ctx.Err())
				return
			case <-ticker.C:
				w.runScans(ctx, out)
			}
		}
	}()

	return out, nil
}

// Name returns the watcher name.
func (w *VulnerabilityWatcher) Name() string {
	return "vulnerability"
}

// runScans runs vulnerability scans on all configured targets.
func (w *VulnerabilityWatcher) runScans(ctx context.Context, out chan<- event.Event) {
	scanner := w.detectScanner()
	if scanner == "" {
		w.logger.Warn("no vulnerability scanner available (trivy auto-download may have failed)")
		return
	}

	scannerPath := ""
	if scanner == ScannerTrivy && w.trivyPath != "" {
		scannerPath = w.trivyPath
	}

	w.logger.Info("running vulnerability scans", "scanner", scanner, "path", scannerPath)

	for _, target := range w.scanTargets {
		select {
		case <-ctx.Done():
			return
		default:
		}

		result, err := w.scanTarget(ctx, scanner, target)
		if err != nil {
			w.logger.Error("vulnerability scan failed",
				"scanner", scanner,
				"target", target.Path,
				"error", err,
			)
			continue
		}

		e := w.createScanEvent(scanner, target, result)
		select {
		case <-ctx.Done():
			return
		case out <- e:
		}

		w.logger.Info("vulnerability scan completed",
			"scanner", scanner,
			"target", target.Path,
			"critical", result.CriticalCount,
			"high", result.HighCount,
			"medium", result.MediumCount,
			"low", result.LowCount,
		)
	}
}

// detectScanner finds an available vulnerability scanner.
// For Trivy, it will auto-download if not present.
func (w *VulnerabilityWatcher) detectScanner() ScannerType {
	if w.scanner != ScannerAuto {
		// Verify the specified scanner is installed
		path := w.getScannerPath(w.scanner)
		if path != "" {
			return w.scanner
		}
		return ""
	}

	// Auto-detect: try trivy first (with auto-download), then grype
	if path := w.getScannerPath(ScannerTrivy); path != "" {
		return ScannerTrivy
	}
	if path := w.getScannerPath(ScannerGrype); path != "" {
		return ScannerGrype
	}

	return ""
}

// getScannerPath returns the path to a scanner binary, downloading Trivy if needed.
func (w *VulnerabilityWatcher) getScannerPath(scanner ScannerType) string {
	if scanner == ScannerTrivy {
		// Try to ensure Trivy is installed (auto-download if needed)
		path, err := EnsureTrivyInstalled()
		if err != nil {
			w.logger.Debug("trivy not available", "error", err)
			return ""
		}
		w.trivyPath = path
		return path
	}

	// For grype, just check if it's in PATH
	path, err := exec.LookPath(string(scanner))
	if err != nil {
		return ""
	}
	return path
}

// isScannerInstalled checks if a scanner binary is available.
func (w *VulnerabilityWatcher) isScannerInstalled(scanner ScannerType) bool {
	return w.getScannerPath(scanner) != ""
}

// scanTarget runs a vulnerability scan on a single target.
func (w *VulnerabilityWatcher) scanTarget(ctx context.Context, scanner ScannerType, target ScanTarget) (*ScanResult, error) {
	var cmd *exec.Cmd

	switch scanner {
	case ScannerTrivy:
		cmd = w.buildTrivyCommand(ctx, target)
	case ScannerGrype:
		cmd = w.buildGrypeCommand(ctx, target)
	default:
		return nil, nil
	}

	output, err := cmd.Output()
	if err != nil {
		// Check if it's an exit error with output (scanner found vulnerabilities)
		if exitErr, ok := err.(*exec.ExitError); ok && len(output) > 0 {
			// Trivy and Grype may exit with non-zero when vulnerabilities are found
			w.logger.Debug("scanner exited with non-zero but has output", "stderr", string(exitErr.Stderr))
		} else {
			return nil, err
		}
	}

	return w.parseOutput(scanner, output)
}

// buildTrivyCommand builds the trivy command for the given target.
func (w *VulnerabilityWatcher) buildTrivyCommand(ctx context.Context, target ScanTarget) *exec.Cmd {
	var args []string

	switch target.Type {
	case ScanTargetFilesystem:
		args = []string{"fs", "--format", "json", "--severity", "CRITICAL,HIGH,MEDIUM,LOW", target.Path}
	case ScanTargetImage:
		args = []string{"image", "--format", "json", "--severity", "CRITICAL,HIGH,MEDIUM,LOW", target.Path}
	}

	// Use cached trivy path if available, otherwise fall back to "trivy"
	trivyBin := "trivy"
	if w.trivyPath != "" {
		trivyBin = w.trivyPath
	}

	cmd := w.execCommand(trivyBin, args...)
	return cmd
}

// buildGrypeCommand builds the grype command for the given target.
func (w *VulnerabilityWatcher) buildGrypeCommand(ctx context.Context, target ScanTarget) *exec.Cmd {
	var args []string

	switch target.Type {
	case ScanTargetFilesystem:
		args = []string{"dir:" + target.Path, "-o", "json"}
	case ScanTargetImage:
		args = []string{target.Path, "-o", "json"}
	}

	cmd := w.execCommand("grype", args...)
	return cmd
}

// ScanResult holds parsed vulnerability scan results.
type ScanResult struct {
	Findings      []event.VulnerabilityItem
	CriticalCount int
	HighCount     int
	MediumCount   int
	LowCount      int
}

// parseOutput parses scanner output based on the scanner type.
func (w *VulnerabilityWatcher) parseOutput(scanner ScannerType, output []byte) (*ScanResult, error) {
	switch scanner {
	case ScannerTrivy:
		return ParseTrivyOutput(output)
	case ScannerGrype:
		return ParseGrypeOutput(output)
	default:
		return &ScanResult{}, nil
	}
}

// TrivyOutput represents the JSON output from trivy.
type TrivyOutput struct {
	Results []TrivyResult `json:"Results"`
}

// TrivyResult represents a single result from trivy.
type TrivyResult struct {
	Target          string            `json:"Target"`
	Vulnerabilities []TrivyVulnerability `json:"Vulnerabilities"`
}

// TrivyVulnerability represents a single vulnerability from trivy.
type TrivyVulnerability struct {
	VulnerabilityID  string `json:"VulnerabilityID"`
	PkgName          string `json:"PkgName"`
	InstalledVersion string `json:"InstalledVersion"`
	FixedVersion     string `json:"FixedVersion"`
	Severity         string `json:"Severity"`
	Description      string `json:"Description"`
	Title            string `json:"Title"`
}

// ParseTrivyOutput parses trivy JSON output into a ScanResult.
func ParseTrivyOutput(output []byte) (*ScanResult, error) {
	if len(output) == 0 {
		return &ScanResult{}, nil
	}

	var trivyOutput TrivyOutput
	if err := json.Unmarshal(output, &trivyOutput); err != nil {
		return nil, err
	}

	result := &ScanResult{
		Findings: make([]event.VulnerabilityItem, 0),
	}

	for _, r := range trivyOutput.Results {
		for _, v := range r.Vulnerabilities {
			severity := normalizeSeverity(v.Severity)

			item := event.VulnerabilityItem{
				CVE:              v.VulnerabilityID,
				Package:          v.PkgName,
				InstalledVersion: v.InstalledVersion,
				FixedVersion:     v.FixedVersion,
				Severity:         severity,
				Description:      truncateDescription(v.Description, v.Title),
				FilePath:         r.Target, // File path where vulnerability was found
			}
			result.Findings = append(result.Findings, item)

			countBySeverity(result, severity)
		}
	}

	return result, nil
}

// GrypeOutput represents the JSON output from grype.
type GrypeOutput struct {
	Matches []GrypeMatch `json:"matches"`
}

// GrypeMatch represents a single match from grype.
type GrypeMatch struct {
	Vulnerability GrypeVulnerability `json:"vulnerability"`
	Artifact      GrypeArtifact      `json:"artifact"`
}

// GrypeVulnerability represents vulnerability info from grype.
type GrypeVulnerability struct {
	ID          string `json:"id"`
	Severity    string `json:"severity"`
	Description string `json:"description"`
	Fix         GrypeFix `json:"fix"`
}

// GrypeFix represents fix info from grype.
type GrypeFix struct {
	Versions []string `json:"versions"`
	State    string   `json:"state"`
}

// GrypeArtifact represents package info from grype.
type GrypeArtifact struct {
	Name    string `json:"name"`
	Version string `json:"version"`
	Type    string `json:"type"`
}

// ParseGrypeOutput parses grype JSON output into a ScanResult.
func ParseGrypeOutput(output []byte) (*ScanResult, error) {
	if len(output) == 0 {
		return &ScanResult{}, nil
	}

	var grypeOutput GrypeOutput
	if err := json.Unmarshal(output, &grypeOutput); err != nil {
		return nil, err
	}

	result := &ScanResult{
		Findings: make([]event.VulnerabilityItem, 0),
	}

	for _, m := range grypeOutput.Matches {
		severity := normalizeSeverity(m.Vulnerability.Severity)

		fixedVersion := ""
		if len(m.Vulnerability.Fix.Versions) > 0 {
			fixedVersion = m.Vulnerability.Fix.Versions[0]
		}

		item := event.VulnerabilityItem{
			CVE:              m.Vulnerability.ID,
			Package:          m.Artifact.Name,
			InstalledVersion: m.Artifact.Version,
			FixedVersion:     fixedVersion,
			Severity:         severity,
			Description:      truncateDescription(m.Vulnerability.Description, ""),
		}
		result.Findings = append(result.Findings, item)

		countBySeverity(result, severity)
	}

	return result, nil
}

// normalizeSeverity converts scanner-specific severity to our standard format.
func normalizeSeverity(severity string) string {
	switch strings.ToLower(severity) {
	case "critical":
		return "critical"
	case "high":
		return "high"
	case "medium":
		return "medium"
	case "low":
		return "low"
	case "negligible", "unknown", "":
		return "low"
	default:
		return "low"
	}
}

// countBySeverity increments the appropriate severity counter.
func countBySeverity(result *ScanResult, severity string) {
	switch severity {
	case "critical":
		result.CriticalCount++
	case "high":
		result.HighCount++
	case "medium":
		result.MediumCount++
	case "low":
		result.LowCount++
	}
}

// truncateDescription returns a truncated description, preferring title if available.
func truncateDescription(description, title string) string {
	text := description
	if title != "" && len(title) < len(description) {
		text = title
	}

	const maxLen = 200
	if len(text) > maxLen {
		return text[:maxLen-3] + "..."
	}
	return text
}

// TriggerScan runs an immediate scan and returns events via the provided channel.
// This is used for on-demand scans triggered by the control plane.
func (w *VulnerabilityWatcher) TriggerScan(ctx context.Context, out chan<- event.Event) {
	w.logger.Info("vulnerability scan triggered by control plane")

	// Emit scan_started event
	startedEvent := event.NewEvent(event.VulnerabilityScanStarted, w.fortressID, w.serverID, map[string]any{
		"trigger":     "control_plane",
		"scan_targets": len(w.scanTargets),
	})
	select {
	case out <- startedEvent:
	case <-ctx.Done():
		return
	}

	w.runScans(ctx, out)
}

// createScanEvent creates a vulnerability scan event.
func (w *VulnerabilityWatcher) createScanEvent(scanner ScannerType, target ScanTarget, result *ScanResult) event.Event {
	scanType := "package"
	if target.Type == ScanTargetImage {
		scanType = "container"
	}

	payload := map[string]any{
		"scan_type":       scanType,
		"scanner":         string(scanner),
		"target":          target.Path,
		"total_findings":  len(result.Findings),
		"critical_count":  result.CriticalCount,
		"high_count":      result.HighCount,
		"medium_count":    result.MediumCount,
		"low_count":       result.LowCount,
		"findings":        result.Findings,
		"os": map[string]any{
			"id":               w.osInfo.ID,
			"name":             w.osInfo.Name,
			"version":          w.osInfo.Version,
			"version_codename": w.osInfo.VersionCodename,
		},
	}

	return event.NewEvent(event.VulnerabilityScan, w.fortressID, w.serverID, payload)
}
