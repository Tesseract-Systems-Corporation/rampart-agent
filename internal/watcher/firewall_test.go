package watcher

import (
	"context"
	"testing"
	"time"

	"github.com/Tesseract-Systems-Corporation/rampart-agent/pkg/event"
)

func TestFirewallWatcherInterface(t *testing.T) {
	var _ Watcher = (*FirewallWatcher)(nil)
}

func TestFirewallWatcherName(t *testing.T) {
	w := NewFirewallWatcher(FirewallConfig{
		PollInterval: 5 * time.Minute,
		FortressID:   "fort_test",
		ServerID:     "srv_test",
	})
	if w.Name() != "firewall" {
		t.Errorf("Name() = %v, want firewall", w.Name())
	}
}

func TestFirewallWatcherConfig(t *testing.T) {
	tests := []struct {
		name             string
		config           FirewallConfig
		wantPollInterval time.Duration
		wantSnapInterval time.Duration
	}{
		{
			name: "default intervals",
			config: FirewallConfig{
				FortressID: "fort_test",
				ServerID:   "srv_test",
			},
			wantPollInterval: 5 * time.Minute,
			wantSnapInterval: 6 * time.Hour,
		},
		{
			name: "custom poll interval",
			config: FirewallConfig{
				PollInterval: 10 * time.Minute,
				FortressID:   "fort_test",
				ServerID:     "srv_test",
			},
			wantPollInterval: 10 * time.Minute,
			wantSnapInterval: 6 * time.Hour,
		},
		{
			name: "custom snapshot interval",
			config: FirewallConfig{
				SnapshotInterval: 12 * time.Hour,
				FortressID:       "fort_test",
				ServerID:         "srv_test",
			},
			wantPollInterval: 5 * time.Minute,
			wantSnapInterval: 12 * time.Hour,
		},
		{
			name: "custom both intervals",
			config: FirewallConfig{
				PollInterval:     1 * time.Minute,
				SnapshotInterval: 1 * time.Hour,
				FortressID:       "fort_test",
				ServerID:         "srv_test",
			},
			wantPollInterval: 1 * time.Minute,
			wantSnapInterval: 1 * time.Hour,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			w := NewFirewallWatcher(tt.config)
			if w.pollInterval != tt.wantPollInterval {
				t.Errorf("pollInterval = %v, want %v", w.pollInterval, tt.wantPollInterval)
			}
			if w.snapshotInterval != tt.wantSnapInterval {
				t.Errorf("snapshotInterval = %v, want %v", w.snapshotInterval, tt.wantSnapInterval)
			}
		})
	}
}

func TestParseIPTablesRules(t *testing.T) {
	tests := []struct {
		name            string
		rules           string
		wantInbound     string
		wantOutbound    string
		wantRuleCount   int
	}{
		{
			name: "default accept policies with rules",
			rules: `# Generated by iptables-save
*filter
:INPUT ACCEPT [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -i lo -j ACCEPT
-A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
-A INPUT -p tcp --dport 22 -j ACCEPT
-A INPUT -p tcp --dport 80 -j ACCEPT
-A INPUT -p tcp --dport 443 -j ACCEPT
-A INPUT -j DROP
COMMIT`,
			wantInbound:   "accept",
			wantOutbound:  "accept",
			wantRuleCount: 6,
		},
		{
			name: "drop policy",
			rules: `*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
-A INPUT -i lo -j ACCEPT
-A INPUT -p tcp --dport 22 -j ACCEPT
COMMIT`,
			wantInbound:   "drop",
			wantOutbound:  "drop",
			wantRuleCount: 2,
		},
		{
			name: "reject policy",
			rules: `*filter
:INPUT REJECT [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -p tcp --dport 22 -j ACCEPT
COMMIT`,
			wantInbound:   "reject",
			wantOutbound:  "accept",
			wantRuleCount: 1,
		},
		{
			name: "multiple tables",
			rules: `*nat
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
-A POSTROUTING -s 10.0.0.0/24 -o eth0 -j MASQUERADE
COMMIT
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -i lo -j ACCEPT
-A INPUT -p tcp --dport 22 -j ACCEPT
-A INPUT -p tcp --dport 80 -j ACCEPT
COMMIT`,
			wantInbound:   "drop",
			wantOutbound:  "accept",
			wantRuleCount: 4, // All -A rules across tables
		},
		{
			name:            "empty rules",
			rules:           "",
			wantInbound:     "accept",
			wantOutbound:    "accept",
			wantRuleCount:   0,
		},
		{
			name: "only comments",
			rules: `# Generated by iptables-save
# This is a comment`,
			wantInbound:   "accept",
			wantOutbound:  "accept",
			wantRuleCount: 0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			inbound, outbound, ruleCount := parseIPTablesRules(tt.rules)
			if inbound != tt.wantInbound {
				t.Errorf("defaultInbound = %v, want %v", inbound, tt.wantInbound)
			}
			if outbound != tt.wantOutbound {
				t.Errorf("defaultOutbound = %v, want %v", outbound, tt.wantOutbound)
			}
			if ruleCount != tt.wantRuleCount {
				t.Errorf("ruleCount = %v, want %v", ruleCount, tt.wantRuleCount)
			}
		})
	}
}

func TestParseIPTablesPolicy(t *testing.T) {
	tests := []struct {
		name       string
		line       string
		wantPolicy string
	}{
		{
			name:       "accept policy",
			line:       ":INPUT ACCEPT [0:0]",
			wantPolicy: "accept",
		},
		{
			name:       "drop policy",
			line:       ":INPUT DROP [0:0]",
			wantPolicy: "drop",
		},
		{
			name:       "reject policy",
			line:       ":OUTPUT REJECT [0:0]",
			wantPolicy: "reject",
		},
		{
			name:       "forward chain",
			line:       ":FORWARD DROP [0:0]",
			wantPolicy: "drop",
		},
		{
			name:       "invalid line",
			line:       "invalid",
			wantPolicy: "accept",
		},
		{
			name:       "empty line",
			line:       "",
			wantPolicy: "accept",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			policy := parseIPTablesPolicy(tt.line)
			if policy != tt.wantPolicy {
				t.Errorf("parseIPTablesPolicy(%q) = %v, want %v", tt.line, policy, tt.wantPolicy)
			}
		})
	}
}

func TestParseNFTablesRules(t *testing.T) {
	tests := []struct {
		name            string
		rules           string
		wantInbound     string
		wantOutbound    string
		wantRuleCount   int
	}{
		{
			name: "basic nftables ruleset",
			rules: `table inet filter {
	chain input {
		type filter hook input priority 0; policy drop;
		iif "lo" accept
		ct state established,related accept
		tcp dport 22 accept
		tcp dport 80 accept
		tcp dport 443 accept
	}

	chain output {
		type filter hook output priority 0; policy accept;
	}
}`,
			wantInbound:   "drop",
			wantOutbound:  "accept",
			wantRuleCount: 5, // 5 lines with accept
		},
		{
			name: "accept policy",
			rules: `table inet filter {
	chain input {
		type filter hook input priority 0; policy accept;
		tcp dport 22 accept
	}

	chain output {
		type filter hook output priority 0; policy accept;
	}
}`,
			wantInbound:   "accept",
			wantOutbound:  "accept",
			wantRuleCount: 1, // only "tcp dport 22 accept" is a rule (policy lines excluded)
		},
		{
			name: "reject policy",
			rules: `table inet filter {
	chain input {
		type filter hook input priority 0; policy reject;
	}

	chain output {
		type filter hook output priority 0; policy drop;
	}
}`,
			wantInbound:   "reject",
			wantOutbound:  "drop",
			wantRuleCount: 0,
		},
		{
			name:            "empty ruleset",
			rules:           "",
			wantInbound:     "accept",
			wantOutbound:    "accept",
			wantRuleCount:   0,
		},
		{
			name: "counter rules",
			rules: `table inet filter {
	chain input {
		type filter hook input priority 0; policy drop;
		counter packets 100 bytes 5000
		tcp dport 22 counter accept
	}
}`,
			wantInbound:   "drop",
			wantOutbound:  "accept",
			wantRuleCount: 2, // counter and accept lines
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			inbound, outbound, ruleCount := parseNFTablesRules(tt.rules)
			if inbound != tt.wantInbound {
				t.Errorf("defaultInbound = %v, want %v", inbound, tt.wantInbound)
			}
			if outbound != tt.wantOutbound {
				t.Errorf("defaultOutbound = %v, want %v", outbound, tt.wantOutbound)
			}
			if ruleCount != tt.wantRuleCount {
				t.Errorf("ruleCount = %v, want %v", ruleCount, tt.wantRuleCount)
			}
		})
	}
}

func TestParseUFWStatus(t *testing.T) {
	tests := []struct {
		name            string
		output          string
		wantEnabled     bool
		wantInbound     string
		wantOutbound    string
		wantRuleCount   int
	}{
		{
			name: "active with rules",
			output: `Status: active
Logging: on (low)
Default: deny (incoming), allow (outgoing), disabled (routed)
New profiles: skip

To                         Action      From
--                         ------      ----
22/tcp                     ALLOW       Anywhere
80/tcp                     ALLOW       Anywhere
443/tcp                    ALLOW       Anywhere
22/tcp (v6)                ALLOW       Anywhere (v6)
80/tcp (v6)                ALLOW       Anywhere (v6)
443/tcp (v6)               ALLOW       Anywhere (v6)`,
			wantEnabled:   true,
			wantInbound:   "deny",
			wantOutbound:  "allow",
			wantRuleCount: 6,
		},
		{
			name: "active with reject incoming",
			output: `Status: active
Logging: on (low)
Default: reject (incoming), allow (outgoing), disabled (routed)
New profiles: skip

To                         Action      From
--                         ------      ----
22/tcp                     ALLOW       Anywhere`,
			wantEnabled:   true,
			wantInbound:   "reject",
			wantOutbound:  "allow",
			wantRuleCount: 1,
		},
		{
			name: "inactive",
			output: `Status: inactive`,
			wantEnabled:   false,
			wantInbound:   "deny",
			wantOutbound:  "allow",
			wantRuleCount: 0,
		},
		{
			name: "active no rules",
			output: `Status: active
Logging: on (low)
Default: deny (incoming), deny (outgoing), disabled (routed)
New profiles: skip

To                         Action      From
--                         ------      ----`,
			wantEnabled:   true,
			wantInbound:   "deny",
			wantOutbound:  "deny",
			wantRuleCount: 0,
		},
		{
			name: "allow incoming",
			output: `Status: active
Logging: on (low)
Default: allow (incoming), allow (outgoing), disabled (routed)
New profiles: skip

To                         Action      From
--                         ------      ----
22/tcp                     DENY        Anywhere`,
			wantEnabled:   true,
			wantInbound:   "allow",
			wantOutbound:  "allow",
			wantRuleCount: 1,
		},
		{
			name:            "empty output",
			output:          "",
			wantEnabled:     false,
			wantInbound:     "deny",
			wantOutbound:    "allow",
			wantRuleCount:   0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			enabled, inbound, outbound, ruleCount := parseUFWStatus(tt.output)
			if enabled != tt.wantEnabled {
				t.Errorf("enabled = %v, want %v", enabled, tt.wantEnabled)
			}
			if inbound != tt.wantInbound {
				t.Errorf("defaultInbound = %v, want %v", inbound, tt.wantInbound)
			}
			if outbound != tt.wantOutbound {
				t.Errorf("defaultOutbound = %v, want %v", outbound, tt.wantOutbound)
			}
			if ruleCount != tt.wantRuleCount {
				t.Errorf("ruleCount = %v, want %v", ruleCount, tt.wantRuleCount)
			}
		})
	}
}

func TestParseUFWPolicy(t *testing.T) {
	tests := []struct {
		name       string
		line       string
		wantPolicy string
	}{
		{
			name:       "deny policy",
			line:       "Default: deny (incoming), allow (outgoing)",
			wantPolicy: "deny",
		},
		{
			name:       "allow policy",
			line:       "Default: allow (incoming), deny (outgoing)",
			wantPolicy: "allow",
		},
		{
			name:       "reject policy",
			line:       "Default: reject (incoming), allow (outgoing)",
			wantPolicy: "reject",
		},
		{
			name:       "outgoing deny",
			line:       "outgoing: deny",
			wantPolicy: "deny",
		},
		{
			name:       "unknown",
			line:       "Default: something else",
			wantPolicy: "unknown",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			policy := parseUFWPolicy(tt.line)
			if policy != tt.wantPolicy {
				t.Errorf("parseUFWPolicy(%q) = %v, want %v", tt.line, policy, tt.wantPolicy)
			}
		})
	}
}

func TestHashRules(t *testing.T) {
	tests := []struct {
		name      string
		rules     string
		wantEmpty bool
	}{
		{
			name:      "empty rules",
			rules:     "",
			wantEmpty: true,
		},
		{
			name:      "non-empty rules",
			rules:     "some rules here",
			wantEmpty: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			hash := hashRules(tt.rules)
			if tt.wantEmpty && hash != "" {
				t.Errorf("hashRules(%q) = %v, want empty", tt.rules, hash)
			}
			if !tt.wantEmpty && hash == "" {
				t.Errorf("hashRules(%q) = empty, want non-empty", tt.rules)
			}
		})
	}

	// Test consistency
	rules := `*filter
:INPUT DROP [0:0]
-A INPUT -p tcp --dport 22 -j ACCEPT
COMMIT`
	hash1 := hashRules(rules)
	hash2 := hashRules(rules)
	if hash1 != hash2 {
		t.Errorf("hash inconsistent: %v != %v", hash1, hash2)
	}

	// Test that hash is 64 characters (SHA256 hex)
	if len(hash1) != 64 {
		t.Errorf("hash length = %d, want 64", len(hash1))
	}

	// Test different content produces different hash
	differentRules := `*filter
:INPUT ACCEPT [0:0]
COMMIT`
	hash3 := hashRules(differentRules)
	if hash1 == hash3 {
		t.Error("different rules should produce different hashes")
	}
}

func TestRuleChangeDetection(t *testing.T) {
	// Test that different rule content produces different hashes
	rules1 := `*filter
:INPUT DROP [0:0]
-A INPUT -p tcp --dport 22 -j ACCEPT
COMMIT`

	rules2 := `*filter
:INPUT DROP [0:0]
-A INPUT -p tcp --dport 22 -j ACCEPT
-A INPUT -p tcp --dport 443 -j ACCEPT
COMMIT`

	hash1 := hashRules(rules1)
	hash2 := hashRules(rules2)

	if hash1 == hash2 {
		t.Error("adding a rule should change the hash")
	}

	// Test same rules produce same hash
	hash3 := hashRules(rules1)
	if hash1 != hash3 {
		t.Error("same rules should produce same hash")
	}
}

func TestParseSSLine(t *testing.T) {
	tests := []struct {
		name        string
		line        string
		protocol    string
		wantPort    int
		wantProto   string
		wantAddr    string
		wantProcess string
		wantNil     bool
	}{
		{
			name:        "tcp listening on all interfaces",
			line:        `LISTEN  0       128            0.0.0.0:22          0.0.0.0:*      users:(("sshd",pid=1234,fd=3))`,
			protocol:    "tcp",
			wantPort:    22,
			wantProto:   "tcp",
			wantAddr:    "0.0.0.0",
			wantProcess: "sshd",
		},
		{
			name:        "tcp listening on localhost",
			line:        `LISTEN  0       128          127.0.0.1:5432        0.0.0.0:*      users:(("postgres",pid=5678,fd=5))`,
			protocol:    "tcp",
			wantPort:    5432,
			wantProto:   "tcp",
			wantAddr:    "127.0.0.1",
			wantProcess: "postgres",
		},
		{
			name:        "tcp6 listening on all interfaces",
			line:        `LISTEN  0       128               :::443              :::*      users:(("nginx",pid=9999,fd=6))`,
			protocol:    "tcp",
			wantPort:    443,
			wantProto:   "tcp",
			wantAddr:    "::",
			wantProcess: "nginx",
		},
		{
			name:        "udp on all interfaces",
			line:        `UNCONN  0       0              0.0.0.0:53          0.0.0.0:*      users:(("dnsmasq",pid=1111,fd=4))`,
			protocol:    "udp",
			wantPort:    53,
			wantProto:   "udp",
			wantAddr:    "0.0.0.0",
			wantProcess: "dnsmasq",
		},
		{
			name:     "header line",
			line:     "State   Recv-Q   Send-Q     Local Address:Port     Peer Address:Port",
			protocol: "tcp",
			wantNil:  true,
		},
		{
			name:     "empty line",
			line:     "",
			protocol: "tcp",
			wantNil:  true,
		},
		{
			name:     "invalid line",
			line:     "invalid",
			protocol: "tcp",
			wantNil:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := parseSSLine(tt.line, tt.protocol)

			if tt.wantNil {
				if result != nil {
					t.Errorf("expected nil, got %+v", result)
				}
				return
			}

			if result == nil {
				t.Fatal("expected result, got nil")
			}

			if result.Port != tt.wantPort {
				t.Errorf("Port = %v, want %v", result.Port, tt.wantPort)
			}
			if result.Protocol != tt.wantProto {
				t.Errorf("Protocol = %v, want %v", result.Protocol, tt.wantProto)
			}
			if result.ListenAddr != tt.wantAddr {
				t.Errorf("ListenAddr = %v, want %v", result.ListenAddr, tt.wantAddr)
			}
			if result.ProcessName != tt.wantProcess {
				t.Errorf("ProcessName = %v, want %v", result.ProcessName, tt.wantProcess)
			}
		})
	}
}

func TestParseSSOutput(t *testing.T) {
	output := `State   Recv-Q   Send-Q     Local Address:Port     Peer Address:Port   Process
LISTEN  0       128            0.0.0.0:22          0.0.0.0:*      users:(("sshd",pid=1234,fd=3))
LISTEN  0       128            0.0.0.0:80          0.0.0.0:*      users:(("nginx",pid=5678,fd=6))
LISTEN  0       128               :::443              :::*      users:(("nginx",pid=5678,fd=7))`

	ports := parseSSOutput(output, "tcp")

	if len(ports) != 3 {
		t.Errorf("expected 3 ports, got %d", len(ports))
	}

	// Check that we got the expected ports
	foundPorts := make(map[int]bool)
	for _, p := range ports {
		foundPorts[p.Port] = true
	}

	expectedPorts := []int{22, 80, 443}
	for _, ep := range expectedPorts {
		if !foundPorts[ep] {
			t.Errorf("expected to find port %d", ep)
		}
	}
}

func TestFirewallWatcherContextCancellation(t *testing.T) {
	w := NewFirewallWatcher(FirewallConfig{
		PollInterval:     1 * time.Hour, // Long interval
		SnapshotInterval: 1 * time.Hour,
		FortressID:       "fort_test",
		ServerID:         "srv_test",
	})

	ctx, cancel := context.WithCancel(context.Background())

	ch, err := w.Watch(ctx)
	if err != nil {
		t.Fatalf("Watch() error = %v", err)
	}

	// Cancel immediately
	cancel()

	// Channel should close
	select {
	case _, ok := <-ch:
		if ok {
			for range ch {
			}
		}
	case <-time.After(500 * time.Millisecond):
		t.Error("channel did not close after context cancellation")
	}
}

func TestFirewallWatcherEmitsSnapshot(t *testing.T) {
	w := NewFirewallWatcher(FirewallConfig{
		PollInterval:     1 * time.Hour,
		SnapshotInterval: 1 * time.Hour,
		FortressID:       "fort_test",
		ServerID:         "srv_test",
	})

	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()

	ch, err := w.Watch(ctx)
	if err != nil {
		t.Fatalf("Watch() error = %v", err)
	}

	// Should receive initial snapshot
	select {
	case e := <-ch:
		if e.Type != event.FirewallStateSnapshot {
			t.Errorf("Type = %v, want %v", e.Type, event.FirewallStateSnapshot)
		}

		// Verify payload fields exist
		payload := e.Payload
		if _, ok := payload["firewall_type"]; !ok {
			t.Error("payload missing firewall_type")
		}
		if _, ok := payload["enabled"]; !ok {
			t.Error("payload missing enabled")
		}
		if _, ok := payload["default_inbound"]; !ok {
			t.Error("payload missing default_inbound")
		}
		if _, ok := payload["default_outbound"]; !ok {
			t.Error("payload missing default_outbound")
		}
		if _, ok := payload["rule_count"]; !ok {
			t.Error("payload missing rule_count")
		}
		if _, ok := payload["rules_hash"]; !ok {
			t.Error("payload missing rules_hash")
		}
		if _, ok := payload["open_ports"]; !ok {
			t.Error("payload missing open_ports")
		}
	case <-time.After(1 * time.Second):
		t.Error("did not receive initial snapshot")
	}
}

func TestFirewallState(t *testing.T) {
	state := &FirewallState{
		FirewallType:    FirewallTypeIPTables,
		Enabled:         true,
		DefaultInbound:  "drop",
		DefaultOutbound: "accept",
		Rules:           "test rules",
		RulesHash:       "abc123",
		RuleCount:       5,
	}

	if state.FirewallType != FirewallTypeIPTables {
		t.Errorf("FirewallType = %v, want %v", state.FirewallType, FirewallTypeIPTables)
	}
	if !state.Enabled {
		t.Error("Enabled should be true")
	}
	if state.DefaultInbound != "drop" {
		t.Errorf("DefaultInbound = %v, want drop", state.DefaultInbound)
	}
	if state.DefaultOutbound != "accept" {
		t.Errorf("DefaultOutbound = %v, want accept", state.DefaultOutbound)
	}
	if state.RuleCount != 5 {
		t.Errorf("RuleCount = %v, want 5", state.RuleCount)
	}
}

func TestFirewallTypes(t *testing.T) {
	// Test that all firewall types are defined
	types := []FirewallType{
		FirewallTypeIPTables,
		FirewallTypeNFTables,
		FirewallTypeUFW,
		FirewallTypeUnknown,
	}

	for _, ft := range types {
		if ft == "" {
			t.Errorf("firewall type should not be empty")
		}
	}

	// Test string values
	if string(FirewallTypeIPTables) != "iptables" {
		t.Errorf("FirewallTypeIPTables = %v, want iptables", FirewallTypeIPTables)
	}
	if string(FirewallTypeNFTables) != "nftables" {
		t.Errorf("FirewallTypeNFTables = %v, want nftables", FirewallTypeNFTables)
	}
	if string(FirewallTypeUFW) != "ufw" {
		t.Errorf("FirewallTypeUFW = %v, want ufw", FirewallTypeUFW)
	}
	if string(FirewallTypeUnknown) != "unknown" {
		t.Errorf("FirewallTypeUnknown = %v, want unknown", FirewallTypeUnknown)
	}
}
