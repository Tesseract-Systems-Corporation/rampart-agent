package watcher

import (
	"bufio"
	"context"
	"crypto/sha256"
	"encoding/hex"
	"io"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
	"time"

	"github.com/Tesseract-Systems-Corporation/rampart-agent/pkg/event"
)

// DefaultMalwareInterval is the default interval between malware scans.
const DefaultMalwareInterval = 6 * time.Hour

// DefaultScanPaths are the default paths to scan with ClamAV.
var DefaultScanPaths = []string{"/tmp", "/var/tmp"}

// AVProvider represents a known antivirus/EDR provider.
type AVProvider struct {
	Name            string
	ProcessNames    []string // Processes to look for
	ServiceNames    []string // Systemd service names to check
	VersionCommand  []string // Command to get version
	StatusCommand   []string // Command to check status
	LogPaths        []string // Log file paths
	DefinitionPaths []string // Definition file paths
}

// KnownAVProviders defines the AV/EDR solutions we detect.
var KnownAVProviders = []AVProvider{
	{
		Name:           "crowdstrike",
		ProcessNames:   []string{"falcon-sensor", "falcond"},
		ServiceNames:   []string{"falcon-sensor"},
		VersionCommand: []string{"/opt/CrowdStrike/falconctl", "-g", "--version"},
		StatusCommand:  []string{"/opt/CrowdStrike/falconctl", "-g", "--rfm-state"},
		LogPaths:       []string{"/var/log/falcon-sensor"},
	},
	{
		Name:           "sentinelone",
		ProcessNames:   []string{"sentinelone", "SentinelAgent", "sentinelctl"},
		ServiceNames:   []string{"sentinelone", "SentinelAgent"},
		VersionCommand: []string{"sentinelctl", "version"},
		StatusCommand:  []string{"sentinelctl", "status"},
		LogPaths:       []string{"/var/log/sentinelone"},
	},
	{
		Name:           "carbon_black",
		ProcessNames:   []string{"cbagentd", "cbsensor"},
		ServiceNames:   []string{"cbagentd", "cbsensor"},
		VersionCommand: []string{"/opt/carbonblack/psc/bin/cbagentd", "--version"},
		LogPaths:       []string{"/var/log/cb"},
	},
	{
		Name:           "microsoft_defender",
		ProcessNames:   []string{"mdatp", "wdavdaemon"},
		ServiceNames:   []string{"mdatp"},
		VersionCommand: []string{"mdatp", "version"},
		StatusCommand:  []string{"mdatp", "health"},
		LogPaths:       []string{"/var/log/microsoft/mdatp"},
	},
	{
		Name:            "clamav",
		ProcessNames:    []string{"clamd", "clamav-daemon"},
		ServiceNames:    []string{"clamav-daemon", "clamd", "clamav-freshclam"},
		VersionCommand:  []string{"clamdscan", "--version"},
		LogPaths:        []string{"/var/log/clamav/clamav.log", "/var/log/clamav/freshclam.log"},
		DefinitionPaths: []string{"/var/lib/clamav"},
	},
	{
		Name:           "sophos",
		ProcessNames:   []string{"sophos", "savd", "sav-protect"},
		ServiceNames:   []string{"sav-protect", "sav-rms"},
		VersionCommand: []string{"/opt/sophos-av/bin/savconfig", "query", "ProductVersion"},
		LogPaths:       []string{"/var/log/sophos"},
	},
	{
		Name:           "eset",
		ProcessNames:   []string{"esets_daemon", "esets_proxy"},
		ServiceNames:   []string{"esets"},
		VersionCommand: []string{"/opt/eset/esets/sbin/esets_daemon", "--version"},
		LogPaths:       []string{"/var/log/eset"},
	},
	{
		Name:           "trend_micro",
		ProcessNames:   []string{"ds_agent", "ds_am"},
		ServiceNames:   []string{"ds_agent"},
		VersionCommand: []string{"/opt/ds_agent/dsa_query", "-c", "GetAgentStatus"},
		LogPaths:       []string{"/var/opt/ds_agent/diag"},
	},
}

// MalwareConfig holds configuration for the Malware watcher.
type MalwareConfig struct {
	// SnapshotInterval is how often to check AV/EDR state and optionally scan.
	// Defaults to DefaultMalwareInterval (6 hours) if zero.
	SnapshotInterval time.Duration

	// EnableClamAVScan enables active ClamAV scanning when no commercial AV is detected.
	// Default is false.
	EnableClamAVScan bool

	// ScanPaths are the paths to scan with ClamAV.
	// Defaults to DefaultScanPaths if empty.
	ScanPaths []string

	// FortressID is the ID of the Fortress this agent belongs to.
	FortressID string

	// ServerID is the ID of this server.
	ServerID string

	// Logger is the logger to use. If nil, uses slog.Default().
	Logger *slog.Logger
}

// AVStatus represents the detected status of an AV/EDR provider.
type AVStatus struct {
	Provider           string
	Status             string // "active", "inactive", "not_installed"
	Version            string
	LastScan           time.Time
	DefinitionsUpdated time.Time
	RealTimeProtection bool
	ProcessRunning     bool
	ServiceRunning     bool
}

// MalwareWatcher monitors for AV/EDR solutions and optionally runs ClamAV scans.
type MalwareWatcher struct {
	snapshotInterval time.Duration
	enableClamAVScan bool
	scanPaths        []string
	fortressID       string
	serverID         string
	logger           *slog.Logger

	// mu protects lastScanResults
	mu              sync.Mutex
	lastScanResults map[string]AVStatus
}

// NewMalwareWatcher creates a new MalwareWatcher with the given configuration.
func NewMalwareWatcher(cfg MalwareConfig) *MalwareWatcher {
	interval := cfg.SnapshotInterval
	if interval == 0 {
		interval = DefaultMalwareInterval
	}

	scanPaths := cfg.ScanPaths
	if len(scanPaths) == 0 {
		scanPaths = DefaultScanPaths
	}

	logger := cfg.Logger
	if logger == nil {
		logger = slog.Default()
	}

	return &MalwareWatcher{
		snapshotInterval: interval,
		enableClamAVScan: cfg.EnableClamAVScan,
		scanPaths:        scanPaths,
		fortressID:       cfg.FortressID,
		serverID:         cfg.ServerID,
		logger:           logger,
		lastScanResults:  make(map[string]AVStatus),
	}
}

// Watch starts watching AV/EDR status and returns a channel of events.
func (w *MalwareWatcher) Watch(ctx context.Context) (<-chan event.Event, error) {
	out := make(chan event.Event)

	go func() {
		defer close(out)

		w.logger.Info("starting malware watcher",
			"interval", w.snapshotInterval,
			"enable_clamav_scan", w.enableClamAVScan,
			"scan_paths", w.scanPaths,
		)

		// Initial scan
		w.emitSnapshot(ctx, out)

		ticker := time.NewTicker(w.snapshotInterval)
		defer ticker.Stop()

		for {
			select {
			case <-ctx.Done():
				w.logger.Info("malware watcher stopped", "reason", ctx.Err())
				return
			case <-ticker.C:
				w.emitSnapshot(ctx, out)
			}
		}
	}()

	return out, nil
}

// Name returns the watcher name.
func (w *MalwareWatcher) Name() string {
	return "malware"
}

// emitSnapshot collects AV/EDR status and emits events.
func (w *MalwareWatcher) emitSnapshot(ctx context.Context, out chan<- event.Event) {
	// Detect all AV/EDR providers
	statuses := w.detectAllProviders()

	// Emit scan events for each detected provider
	for _, status := range statuses {
		if status.Status != "not_installed" {
			w.emitMalwareScan(ctx, out, status)
		}
	}

	// Check if we found any active commercial AV
	hasCommercialAV := false
	for _, status := range statuses {
		if status.Status == "active" && status.Provider != "clamav" {
			hasCommercialAV = true
			break
		}
	}

	// If no commercial AV and ClamAV scan is enabled, run scan
	if !hasCommercialAV && w.enableClamAVScan {
		// Check if ClamAV is installed
		if clamStatus, ok := statuses["clamav"]; ok && clamStatus.Status != "not_installed" {
			w.runClamAVScan(ctx, out)
		} else {
			w.logger.Warn("ClamAV scan enabled but ClamAV not installed")
		}
	}

	// Store results for comparison
	w.mu.Lock()
	w.lastScanResults = statuses
	w.mu.Unlock()
}

// detectAllProviders checks all known AV/EDR providers and returns their status.
func (w *MalwareWatcher) detectAllProviders() map[string]AVStatus {
	statuses := make(map[string]AVStatus)

	// Get list of running processes once
	runningProcesses := w.getRunningProcesses()

	for _, provider := range KnownAVProviders {
		status := w.detectProvider(provider, runningProcesses)
		statuses[provider.Name] = status
	}

	return statuses
}

// detectProvider checks a single AV/EDR provider's status.
func (w *MalwareWatcher) detectProvider(provider AVProvider, runningProcesses map[string]bool) AVStatus {
	status := AVStatus{
		Provider: provider.Name,
		Status:   "not_installed",
	}

	// Check for running processes
	for _, procName := range provider.ProcessNames {
		if runningProcesses[procName] {
			status.ProcessRunning = true
			status.Status = "active"
			break
		}
	}

	// Check systemd service status
	for _, serviceName := range provider.ServiceNames {
		if w.isServiceRunning(serviceName) {
			status.ServiceRunning = true
			if status.Status == "not_installed" {
				status.Status = "inactive" // Service exists but process not running
			}
			break
		}
	}

	// If we found evidence of the provider, try to get more info
	if status.Status != "not_installed" {
		// Get version
		if len(provider.VersionCommand) > 0 {
			if version := w.runCommand(provider.VersionCommand); version != "" {
				status.Version = strings.TrimSpace(version)
			}
		}

		// Check status/real-time protection
		if len(provider.StatusCommand) > 0 {
			if statusOutput := w.runCommand(provider.StatusCommand); statusOutput != "" {
				status.RealTimeProtection = w.parseRealTimeProtection(provider.Name, statusOutput)
			}
		}

		// Parse logs for last scan time and definition updates
		status.LastScan, status.DefinitionsUpdated = w.parseProviderLogs(provider)
	}

	return status
}

// getRunningProcesses returns a map of running process names.
func (w *MalwareWatcher) getRunningProcesses() map[string]bool {
	processes := make(map[string]bool)

	// Use ps to get all running processes
	output, err := exec.Command("ps", "aux").Output()
	if err != nil {
		w.logger.Debug("failed to list processes", "error", err)
		return processes
	}

	scanner := bufio.NewScanner(strings.NewReader(string(output)))
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)
		if len(fields) >= 11 {
			// The command is usually in field 10 (0-indexed)
			cmd := fields[10]
			// Extract just the process name
			procName := filepath.Base(cmd)
			processes[procName] = true
			// Also check full command line for matches
			fullCmd := strings.Join(fields[10:], " ")
			processes[fullCmd] = true
		}
	}

	return processes
}

// isServiceRunning checks if a systemd service is running.
func (w *MalwareWatcher) isServiceRunning(serviceName string) bool {
	output, err := exec.Command("systemctl", "is-active", serviceName).Output()
	if err != nil {
		return false
	}
	return strings.TrimSpace(string(output)) == "active"
}

// runCommand executes a command and returns its output.
func (w *MalwareWatcher) runCommand(args []string) string {
	if len(args) == 0 {
		return ""
	}

	cmd := exec.Command(args[0], args[1:]...)
	output, err := cmd.Output()
	if err != nil {
		return ""
	}
	return string(output)
}

// parseRealTimeProtection determines if real-time protection is enabled based on status output.
func (w *MalwareWatcher) parseRealTimeProtection(provider, statusOutput string) bool {
	statusLower := strings.ToLower(statusOutput)

	switch provider {
	case "crowdstrike":
		// RFM state of 0 means sensor is not in reduced functionality mode
		return !strings.Contains(statusLower, "rfm-state=true")
	case "microsoft_defender":
		return strings.Contains(statusLower, "real_time_protection_enabled") &&
			strings.Contains(statusLower, "true")
	case "sentinelone":
		return strings.Contains(statusLower, "protection: enabled") ||
			strings.Contains(statusLower, "agent_enabled")
	case "carbon_black":
		return strings.Contains(statusLower, "sensor is running")
	case "sophos":
		return strings.Contains(statusLower, "on-access scanning is running")
	case "clamav":
		// ClamAV with clamd running provides on-access scanning
		return true // clamd itself is the real-time daemon
	default:
		// Default: assume active if service is running
		return strings.Contains(statusLower, "running") ||
			strings.Contains(statusLower, "active") ||
			strings.Contains(statusLower, "enabled")
	}
}

// parseProviderLogs parses log files to extract last scan time and definition update time.
func (w *MalwareWatcher) parseProviderLogs(provider AVProvider) (lastScan, defsUpdated time.Time) {
	for _, logPath := range provider.LogPaths {
		// Handle directory paths
		info, err := os.Stat(logPath)
		if err != nil {
			continue
		}

		var files []string
		if info.IsDir() {
			entries, err := os.ReadDir(logPath)
			if err != nil {
				continue
			}
			for _, entry := range entries {
				if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".log") {
					files = append(files, filepath.Join(logPath, entry.Name()))
				}
			}
		} else {
			files = []string{logPath}
		}

		for _, file := range files {
			scanTime, defTime := w.parseLogFile(provider.Name, file)
			if !scanTime.IsZero() && (lastScan.IsZero() || scanTime.After(lastScan)) {
				lastScan = scanTime
			}
			if !defTime.IsZero() && (defsUpdated.IsZero() || defTime.After(defsUpdated)) {
				defsUpdated = defTime
			}
		}
	}

	// For ClamAV, also check definition file timestamps
	if provider.Name == "clamav" {
		for _, defPath := range provider.DefinitionPaths {
			if info, err := os.Stat(defPath); err == nil {
				if info.IsDir() {
					// Check for main.cvd or daily.cvd
					for _, defFile := range []string{"main.cvd", "daily.cvd", "main.cld", "daily.cld"} {
						fullPath := filepath.Join(defPath, defFile)
						if finfo, err := os.Stat(fullPath); err == nil {
							modTime := finfo.ModTime()
							if defsUpdated.IsZero() || modTime.After(defsUpdated) {
								defsUpdated = modTime
							}
						}
					}
				}
			}
		}
	}

	return lastScan, defsUpdated
}

// parseLogFile parses a single log file for scan and definition update times.
func (w *MalwareWatcher) parseLogFile(provider, logPath string) (lastScan, defsUpdated time.Time) {
	file, err := os.Open(logPath)
	if err != nil {
		return
	}
	defer file.Close()

	// Only read last 10KB of file to avoid reading huge logs
	info, err := file.Stat()
	if err != nil {
		return
	}
	if info.Size() > 10*1024 {
		file.Seek(-10*1024, io.SeekEnd)
	}

	scanner := bufio.NewScanner(file)

	// Patterns for different providers
	var scanPattern, defPattern *regexp.Regexp

	switch provider {
	case "clamav":
		// ClamAV freshclam.log: "ClamAV update process started at Thu Jan  2 10:00:00 2025"
		// ClamAV clamav.log: "Scan started: Thu Jan 2 10:00:00 2025"
		scanPattern = regexp.MustCompile(`(?i)scan\s+(started|completed|finished).*?(\w{3}\s+\w{3}\s+\d+\s+\d+:\d+:\d+\s+\d{4})`)
		defPattern = regexp.MustCompile(`(?i)(database\s+updated|is\s+up\s+to\s+date).*?(\w{3}\s+\w{3}\s+\d+\s+\d+:\d+:\d+\s+\d{4})`)
	default:
		// Generic patterns
		scanPattern = regexp.MustCompile(`(?i)scan\s+(completed|finished|ended)`)
		defPattern = regexp.MustCompile(`(?i)(definition|signature|database)\s+(updated|downloaded)`)
	}

	for scanner.Scan() {
		line := scanner.Text()

		if scanPattern != nil {
			if matches := scanPattern.FindStringSubmatch(line); len(matches) > 2 {
				if t, err := time.Parse("Mon Jan 2 15:04:05 2006", matches[2]); err == nil {
					if lastScan.IsZero() || t.After(lastScan) {
						lastScan = t
					}
				}
			}
		}

		if defPattern != nil {
			if matches := defPattern.FindStringSubmatch(line); len(matches) > 2 {
				if t, err := time.Parse("Mon Jan 2 15:04:05 2006", matches[2]); err == nil {
					if defsUpdated.IsZero() || t.After(defsUpdated) {
						defsUpdated = t
					}
				}
			}
		}
	}

	return lastScan, defsUpdated
}

// emitMalwareScan emits a malware.scan event for a detected provider.
func (w *MalwareWatcher) emitMalwareScan(ctx context.Context, out chan<- event.Event, status AVStatus) {
	payload := map[string]any{
		"provider":             status.Provider,
		"status":               status.Status,
		"real_time_protection": status.RealTimeProtection,
	}

	if status.Version != "" {
		payload["version"] = status.Version
	}

	if !status.LastScan.IsZero() {
		payload["last_scan"] = status.LastScan.Format(time.RFC3339)
	}

	if !status.DefinitionsUpdated.IsZero() {
		payload["definitions_updated"] = status.DefinitionsUpdated.Format(time.RFC3339)
	}

	e := event.NewEvent(event.MalwareScan, w.fortressID, w.serverID, payload)

	w.logger.Debug("emitting malware scan event",
		"provider", status.Provider,
		"status", status.Status,
		"version", status.Version,
	)

	select {
	case <-ctx.Done():
	case out <- e:
	}
}

// runClamAVScan runs ClamAV scans on configured paths and emits detection events.
func (w *MalwareWatcher) runClamAVScan(ctx context.Context, out chan<- event.Event) {
	w.logger.Info("running ClamAV scan", "paths", w.scanPaths)

	for _, scanPath := range w.scanPaths {
		select {
		case <-ctx.Done():
			return
		default:
		}

		// Check if path exists
		if _, err := os.Stat(scanPath); os.IsNotExist(err) {
			w.logger.Debug("scan path does not exist", "path", scanPath)
			continue
		}

		// Run clamscan (or clamdscan if clamd is running)
		var cmd *exec.Cmd
		if w.isClamdRunning() {
			cmd = exec.CommandContext(ctx, "clamdscan", "--infected", "--no-summary", scanPath)
		} else {
			cmd = exec.CommandContext(ctx, "clamscan", "--infected", "--recursive", "--no-summary", scanPath)
		}

		output, err := cmd.Output()
		if err != nil {
			// Exit code 1 means virus found, which is not an error for us
			if exitErr, ok := err.(*exec.ExitError); ok && exitErr.ExitCode() == 1 {
				// Virus found - parse output
				w.parseClamAVOutput(ctx, out, string(output))
			} else if exitErr == nil || exitErr.ExitCode() != 1 {
				w.logger.Debug("clamscan failed", "path", scanPath, "error", err)
			}
		}
		// Exit code 0 means no virus found - no events to emit
	}
}

// isClamdRunning checks if the ClamAV daemon is running.
func (w *MalwareWatcher) isClamdRunning() bool {
	// Try to connect to clamd
	output, err := exec.Command("clamdscan", "--ping").Output()
	if err != nil {
		return false
	}
	return strings.Contains(string(output), "PONG")
}

// parseClamAVOutput parses clamscan output and emits detection events.
func (w *MalwareWatcher) parseClamAVOutput(ctx context.Context, out chan<- event.Event, output string) {
	// ClamAV output format: /path/to/file: Malware.Name FOUND
	foundPattern := regexp.MustCompile(`^(.+?):\s+(.+?)\s+FOUND$`)

	scanner := bufio.NewScanner(strings.NewReader(output))
	for scanner.Scan() {
		line := scanner.Text()

		matches := foundPattern.FindStringSubmatch(line)
		if len(matches) != 3 {
			continue
		}

		filePath := matches[1]
		malwareName := matches[2]

		// Calculate file hash
		hash := w.calculateFileHash(filePath)

		payload := map[string]any{
			"scanner":      "clamav",
			"malware_name": malwareName,
			"file_path":    filePath,
			"action":       "detected",
			"severity":     w.classifyMalwareSeverity(malwareName),
			"scan_type":    "scheduled",
		}

		if hash != "" {
			payload["hash"] = hash
		}

		e := event.NewEvent(event.MalwareDetected, w.fortressID, w.serverID, payload)

		w.logger.Warn("malware detected",
			"malware_name", malwareName,
			"file_path", filePath,
			"hash", hash,
		)

		select {
		case <-ctx.Done():
			return
		case out <- e:
		}
	}
}

// calculateFileHash calculates SHA256 hash of a file.
func (w *MalwareWatcher) calculateFileHash(filePath string) string {
	file, err := os.Open(filePath)
	if err != nil {
		return ""
	}
	defer file.Close()

	hasher := sha256.New()
	if _, err := io.Copy(hasher, file); err != nil {
		return ""
	}

	return hex.EncodeToString(hasher.Sum(nil))
}

// classifyMalwareSeverity classifies malware severity based on its name.
func (w *MalwareWatcher) classifyMalwareSeverity(malwareName string) string {
	nameLower := strings.ToLower(malwareName)

	// Critical threats
	criticalPatterns := []string{
		"trojan", "backdoor", "rootkit", "ransomware", "cryptolocker",
		"keylogger", "rat", "exploit", "shellcode",
	}
	for _, pattern := range criticalPatterns {
		if strings.Contains(nameLower, pattern) {
			return "critical"
		}
	}

	// High severity
	highPatterns := []string{
		"worm", "virus", "dropper", "downloader", "banker", "stealer",
		"miner", "cryptominer", "coinminer",
	}
	for _, pattern := range highPatterns {
		if strings.Contains(nameLower, pattern) {
			return "high"
		}
	}

	// Medium severity
	mediumPatterns := []string{
		"adware", "spyware", "pup", "potentially", "unwanted", "hacktool",
	}
	for _, pattern := range mediumPatterns {
		if strings.Contains(nameLower, pattern) {
			return "medium"
		}
	}

	// Default to high for unknown malware
	return "high"
}

// TriggerScan runs an immediate AV/EDR status check and optional ClamAV scan.
// This is used for on-demand scans triggered by the control plane.
func (w *MalwareWatcher) TriggerScan(ctx context.Context, out chan<- event.Event) {
	w.logger.Info("malware scan triggered by control plane")

	// Emit scan_started event
	startedEvent := event.NewEvent(event.MalwareScan, w.fortressID, w.serverID, map[string]any{
		"trigger": "control_plane",
		"status":  "scan_started",
	})
	select {
	case out <- startedEvent:
	case <-ctx.Done():
		return
	}

	// Run the normal snapshot which checks all AV/EDR providers
	w.emitSnapshot(ctx, out)
}
